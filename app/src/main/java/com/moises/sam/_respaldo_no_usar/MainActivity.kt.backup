package com.moises.sam

import android.Manifest
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.EditText
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.TableLayout
import android.widget.TableRow
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.google.android.material.button.MaterialButton
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.moises.sam.data.SamRepository
import com.moises.sam.model.Adelanto
import com.moises.sam.model.Pago
import com.moises.sam.model.Registro
import com.moises.sam.model.TipoBordado
import com.moises.sam.model.TipoServicio
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

class MainActivity : AppCompatActivity() {
    
    // Repositorio para acceder a datos
    private lateinit var repository: SamRepository
    
    // Botones principales
    private lateinit var btnBordados: MaterialButton
    private lateinit var btnPlanchados: MaterialButton
    private lateinit var btnRegistroJefe: MaterialButton
    private lateinit var btnDescargarPdf: MaterialButton
    private lateinit var btnAdelantos: MaterialButton
    private lateinit var btnRegistroClemente: MaterialButton
    private lateinit var btnPagosClemente: MaterialButton
    private lateinit var btnRegistroLalo: MaterialButton
    private lateinit var btnPagosLalo: MaterialButton
    
    // Permisos
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        var allPermissionsGranted = true
        permissions.entries.forEach {
            Log.d("MainActivity", "Permiso ${it.key}: ${if (it.value) "concedido" else "denegado"}")
            if (!it.value) allPermissionsGranted = false
        }
        
        if (allPermissionsGranted) {
            Log.i("MainActivity", "Todos los permisos necesarios han sido concedidos")
            Toast.makeText(this, "Permisos concedidos.", Toast.LENGTH_SHORT).show()
        } else {
            Log.w("MainActivity", "Algunos permisos fueron denegados")
            Toast.makeText(this, "Algunos permisos fueron denegados.", Toast.LENGTH_LONG).show()
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // Inicializar el repositorio
        repository = SamRepository(applicationContext)
        
        initViews()
        setupClickListeners()
    }
    
    private fun initViews() {
        // Inicializar todos los botones
        btnBordados = findViewById(R.id.btn_bordados)
        btnPlanchados = findViewById(R.id.btn_planchados)
        btnRegistroJefe = findViewById(R.id.btn_registro_jefe)
        btnDescargarPdf = findViewById(R.id.btn_descargar_pdf)
        btnAdelantos = findViewById(R.id.btn_adelantos)
        btnRegistroClemente = findViewById(R.id.btn_registro_clemente)
        btnPagosClemente = findViewById(R.id.btn_pagos_clemente)
        btnRegistroLalo = findViewById(R.id.btn_registro_lalo)
        btnPagosLalo = findViewById(R.id.btn_pagos_lalo)
        
        // Inicializar FAB
        val fabAdd: com.google.android.material.floatingactionbutton.FloatingActionButton = findViewById(R.id.fab_add)
        fabAdd.setOnClickListener {
            mostrarDialogoSeleccionServicio()
        }
    }
    
    private fun setupClickListeners() {
        // MODAL: Registro de bordados para Jefe
        btnBordados.setOnClickListener {
            mostrarDialogoRegistroServicio(TipoServicio.BORDADO) { cantidad ->
                // Registrar bordado: Precio fijo 0.50 por unidad
                val total = cantidad * 0.50
                registrarServicio(TipoServicio.BORDADO, cantidad, total)
                Toast.makeText(this, "Bordado registrado: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
            }
        }
        
        // MODAL: Registro de planchado para Jefe
        btnPlanchados.setOnClickListener {
            mostrarDialogoRegistroServicio(TipoServicio.PLANCHADO) { cantidad ->
                // Registrar planchado: Precio fijo 1.00 por unidad
                val total = cantidad * 1.00
                registrarServicio(TipoServicio.PLANCHADO, cantidad, total)
                Toast.makeText(this, "Planchado registrado: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
            }
        }
        
        // Ver registros de bordado/planchado (Jefe)
        btnRegistroJefe.setOnClickListener {
            mostrarDialogoVerRegistros("Registros de Jefe", listOf(TipoServicio.BORDADO, TipoServicio.PLANCHADO))
        }
        
        // Descargar informe PDF
        btnDescargarPdf.setOnClickListener {
            if (hasStoragePermissions()) {
                Toast.makeText(this, "Generando PDF...", Toast.LENGTH_SHORT).show()
                generarPDF()
            } else {
                requestStoragePermissions()
                Toast.makeText(this, "Se necesitan permisos de almacenamiento", Toast.LENGTH_SHORT).show()
            }
        }
        
        // MODAL: Registro de adelantos para Jefe
        btnAdelantos.setOnClickListener {
            mostrarDialogoRegistroPago("Adelanto") { monto ->
                registrarPago(monto, "Adelanto")
                Toast.makeText(this, "Adelanto registrado: S/ $monto", Toast.LENGTH_SHORT).show()
                actualizarSaldos()
            }
        }
        
        // Ver registros de chompas (Clemente)
        btnRegistroClemente.setOnClickListener {
            // Mostrar menú contextual para elegir entre ver registros o registrar nuevo servicio
            val popupMenu = android.widget.PopupMenu(this, btnRegistroClemente)
            popupMenu.menu.add("Ver Registros").setOnMenuItemClickListener {
                mostrarDialogoVerRegistros("Registros de Clemente", listOf(TipoServicio.CHOMPA))
                true
            }
            popupMenu.menu.add("Registrar Nuevo").setOnMenuItemClickListener {
                mostrarDialogoRegistroServicio(TipoServicio.CHOMPA) { cantidad ->
                    val precioUnitario = 1.00
                    val total = cantidad * precioUnitario
                    registrarServicio(TipoServicio.CHOMPA, cantidad, total)
                    Toast.makeText(this, "Chompa registrada: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
                    actualizarSaldos()
                }
                true
            }
            popupMenu.show()
        }
        
        // MODAL: Registro de pago simple para Clemente
        btnPagosClemente.setOnClickListener {
            mostrarDialogoRegistroPago("Pago a Clemente") { monto ->
                registrarPago(monto, "Pago a Clemente")
                Toast.makeText(this, "Pago registrado (Clemente): S/ $monto", Toast.LENGTH_SHORT).show()
                actualizarSaldos()
            }
        }
        
        // Ver registros de ponchos (Lalo)
        btnRegistroLalo.setOnClickListener {
            // Mostrar menú contextual para elegir entre ver registros o registrar nuevo servicio
            val popupMenu = android.widget.PopupMenu(this, btnRegistroLalo)
            popupMenu.menu.add("Ver Registros").setOnMenuItemClickListener {
                mostrarDialogoVerRegistros("Registros de Lalo", listOf(TipoServicio.PONCHO))
                true
            }
            popupMenu.menu.add("Registrar Nuevo").setOnMenuItemClickListener {
                mostrarDialogoRegistroServicio(TipoServicio.PONCHO) { cantidad ->
                    val total = cantidad * 2.50
                    registrarServicio(TipoServicio.PONCHO, cantidad, total)
                    Toast.makeText(this, "Poncho registrado: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
                    actualizarSaldos()
                }
                true
            }
            popupMenu.show()
        }
        
        // MODAL: Registro de pago simple para Lalo
        btnPagosLalo.setOnClickListener {
            mostrarDialogoRegistroPago("Pago a Lalo") { monto ->
                registrarPago(monto, "Pago a Lalo")
                Toast.makeText(this, "Pago registrado (Lalo): S/ $monto", Toast.LENGTH_SHORT).show()
                actualizarSaldos()
            }
        }
    }

    // Función para mostrar el diálogo de registro de pagos y adelantos mejorado
    private fun mostrarDialogoRegistroPago(titulo: String = "Registro", onRegistrar: (Double) -> Unit) {
        // Crear el diálogo
        val dialog = android.app.Dialog(this)
        dialog.requestWindowFeature(android.view.Window.FEATURE_NO_TITLE)
        dialog.setContentView(R.layout.dialog_pago_adelanto)
        dialog.window?.setBackgroundDrawable(android.graphics.drawable.ColorDrawable(android.graphics.Color.TRANSPARENT))
        dialog.setCancelable(true)
        
        // Configurar vistas
        val tvTitulo = dialog.findViewById<TextView>(R.id.tv_pago_title)
        val etMonto = dialog.findViewById<com.google.android.material.textfield.TextInputEditText>(R.id.et_pago_monto)
        val etObservacion = dialog.findViewById<com.google.android.material.textfield.TextInputEditText>(R.id.et_pago_observacion)
        val rgTipoPago = dialog.findViewById<RadioGroup>(R.id.rg_tipo_pago)
        val rbPago = dialog.findViewById<RadioButton>(R.id.rb_pago)
        val rbAdelanto = dialog.findViewById<RadioButton>(R.id.rb_adelanto)
        val btnRegistrar = dialog.findViewById<Button>(R.id.btn_pago_registrar)
        val btnCancelar = dialog.findViewById<Button>(R.id.btn_pago_cancelar)
        
        // Establecer título
        tvTitulo.text = titulo
        
        // Configurar listeners
        btnRegistrar.setOnClickListener {
            val monto = etMonto.text.toString().toDoubleOrNull()
            if (monto != null && monto > 0) {
                val esAdelanto = rbAdelanto.isChecked
                val observacion = etObservacion.text.toString().trim().ifEmpty {
                    if (esAdelanto) "Adelanto: $titulo" else "Pago: $titulo"
                }
                
                if (esAdelanto) {
                    // Si es adelanto, registrar adelanto
                    registrarAdelanto(monto)
                    Toast.makeText(this, "Adelanto registrado: S/ $monto", Toast.LENGTH_SHORT).show()
                    actualizarSaldos()
                } else {
                    // Si es pago normal, registrar pago
                    onRegistrar(monto)
                }
                
                dialog.dismiss()
            } else {
                etMonto.error = "Ingresa un monto válido"
            }
        }
        
        btnCancelar.setOnClickListener {
            dialog.dismiss()
        }
        
        dialog.show()
    }
    
    // Registrar un adelanto en la base de datos
    private fun registrarAdelanto(monto: Double) {
        // Guardar en base de datos en un hilo secundario
        lifecycleScope.launch(Dispatchers.IO) {
            // Actualizar configuración de adelantos
            val config = repository.getConfiguracion()
            repository.actualizarAdelantos(config.adelantos + monto)
            
            // Actualizar UI en hilo principal
            withContext(Dispatchers.Main) {
                actualizarSaldos()
            }
        }
    }
    
    // Función para mostrar el diálogo de registro de servicios
    private fun mostrarDialogoRegistroServicio(tipoServicio: TipoServicio, onRegistrar: (Int) -> Unit) {
        // Crear el diálogo
        val dialog = android.app.Dialog(this)
        dialog.requestWindowFeature(android.view.Window.FEATURE_NO_TITLE)
        dialog.setContentView(R.layout.dialog_registro_servicio)
        dialog.window?.setBackgroundDrawable(android.graphics.drawable.ColorDrawable(android.graphics.Color.TRANSPARENT))
        dialog.setCancelable(true)
        
        // Configurar título según el tipo de servicio
        val titulo = when(tipoServicio) {
            TipoServicio.BORDADO -> "Registro de Bordados"
            TipoServicio.PLANCHADO -> "Registro de Planchados"
            TipoServicio.CHOMPA -> "Registro de Chompas"
            TipoServicio.PONCHO -> "Registro de Ponchos"
        }
        
        // Configurar precio unitario según el tipo de servicio
        val precioUnitario = when(tipoServicio) {
            TipoServicio.BORDADO -> "Precio unitario: S/ 0.50"
            TipoServicio.PLANCHADO -> "Precio unitario: S/ 1.00"
            TipoServicio.CHOMPA -> "Precio unitario: S/ 1.00"
            TipoServicio.PONCHO -> "Precio unitario: S/ 2.50"
        }
        
        // Configurar vistas del diálogo
        val tvTitulo = dialog.findViewById<TextView>(R.id.tv_dialog_title)
        val tvPrecioUnitario = dialog.findViewById<TextView>(R.id.tv_precio_unitario)
        val etCantidad = dialog.findViewById<com.google.android.material.textfield.TextInputEditText>(R.id.et_cantidad)
        val btnRegistrar = dialog.findViewById<Button>(R.id.btn_registrar)
        val btnCancelar = dialog.findViewById<Button>(R.id.btn_cancel)
        
        // Establecer valores
        tvTitulo.text = titulo
        tvPrecioUnitario.text = precioUnitario

        // Configurar listeners
        btnRegistrar.setOnClickListener {
            val cantidad = etCantidad.text.toString().toIntOrNull()
            if (cantidad != null && cantidad > 0) {
                onRegistrar(cantidad)
                dialog.dismiss()
            } else {
                etCantidad.error = "Ingresa una cantidad válida"
            }
        }
        
        btnCancelar.setOnClickListener {
            dialog.dismiss()
        }
        
        dialog.show()
    }
    
    // Verifico permisos de almacenamiento para futuro uso
    private fun hasStoragePermissions(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES) == PackageManager.PERMISSION_GRANTED
        } else {
            ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED &&
            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED
        }
    }
    
    private fun requestStoragePermissions() {
        Log.d("MainActivity", "Iniciando verificación de permisos...")
        
        val permissionsToRequest = mutableListOf<String>()
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES) != PackageManager.PERMISSION_GRANTED) {
                permissionsToRequest.add(Manifest.permission.READ_MEDIA_IMAGES)
            }
        } else {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                permissionsToRequest.add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
            }
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                permissionsToRequest.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }
        
        if (permissionsToRequest.isNotEmpty()) {
            requestPermissionLauncher.launch(permissionsToRequest.toTypedArray())
        } else {
            Log.i("MainActivity", "Todos los permisos ya están concedidos")
        }
    }
    
    // Registrar un servicio en la base de datos
    private fun registrarServicio(tipoServicio: TipoServicio, cantidad: Int, total: Double) {
        // Crear objeto registro
        val registro = com.moises.sam.model.Registro(
            fecha = Date(),
            cantidad = cantidad,
            total = total,
            tipo = tipoServicio,
            isPagado = false
        )
        
        // Guardar en base de datos en un hilo secundario
        lifecycleScope.launch(Dispatchers.IO) {
            repository.saveRegistro(registro)
            
            // Actualizar UI en hilo principal
            withContext(Dispatchers.Main) {
                actualizarSaldos()
            }
        }
    }
    
    // Registrar un pago en la base de datos
    private fun registrarPago(monto: Double, observacion: String) {
        // Crear objeto pago
        val pago = com.moises.sam.model.Pago(
            fecha = Date(),
            monto = monto,
            observacion = observacion
        )
        
        // Guardar en base de datos en un hilo secundario
        lifecycleScope.launch(Dispatchers.IO) {
            repository.savePago(pago)
            
            // Actualizar UI en hilo principal
            withContext(Dispatchers.Main) {
                actualizarSaldos()
            }
        }
    }
    
    // Método para crear la clase Registro a partir de un tipo de registro
    private fun createRegistro(tipo: TipoServicio, cantidad: Int, total: Double): com.moises.sam.model.Registro {
        return com.moises.sam.model.Registro(
            id = 0, // El ID se generará automáticamente
            fecha = Date(),
            tipo = tipo,
            cantidad = cantidad,
            total = total
        )
    }
            }
        }
    }
    
    // Actualizar los saldos y los contadores en la UI
    private fun actualizarSaldos() {
        val repository = com.moises.sam.data.SamRepository(this)
        
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                // Obtener datos actualizados
                val config = repository.getConfiguracion()
                val registrosBordadoPlanchado = repository.getRegistrosBordadoPlanchado()
                val registrosChompas = repository.getRegistrosChompas()
                val registrosPonchos = repository.getRegistrosPonchos()
                val pagosDiarios = repository.getPagosDiarios()
                
                // Calcular saldos
                val saldoBordadoPlanchado = registrosBordadoPlanchado.sumOf { it.total }
                val saldoChompas = registrosChompas.sumOf { it.total }
                val saldoPonchos = registrosPonchos.sumOf { it.total }
                val cantidadPonchos = registrosPonchos.sumOf { it.cantidad }
                val totalPagosDiarios = pagosDiarios.sumOf { it.monto }
                
                // Guardar en la base de datos
                repository.actualizarSaldos(
                    saldoBordadoPlanchado = saldoBordadoPlanchado,
                    adelantos = config.adelantos,
                    saldoChompas = saldoChompas,
                    saldoPonchos = saldoPonchos,
                    cantidadPonchos = cantidadPonchos
                )
                
                // Actualizar UI en el hilo principal
                withContext(Dispatchers.Main) {
                    // Calcular total general
                    val totalGeneral = saldoBordadoPlanchado + saldoChompas + saldoPonchos
                    
                    // Incluir saldo anterior en el cálculo del saldo general
                    val saldoTotal = totalGeneral + (config.saldoAnterior ?: 0.0)
                    
                    // Actualizar textos de saldos con colores apropiados
                    val tvTotal = findViewById<TextView>(R.id.tv_total)
                    tvTotal.text = "Total: S/ ${String.format("%.2f", totalGeneral)}"
                    
                    val tvHoy = findViewById<TextView>(R.id.tv_hoy)
                    tvHoy.text = "Hoy: S/ ${String.format("%.2f", totalPagosDiarios)}"
                    
                    // Saldo general con color según valor
                    val tvSaldoGeneral = findViewById<TextView>(R.id.tv_saldo_general)
                    val saldoGeneralFinal = saldoTotal - config.adelantos
                    tvSaldoGeneral.text = "Saldo: S/ ${String.format("%.2f", saldoGeneralFinal)}"
                    if (saldoGeneralFinal > 0) {
                        tvSaldoGeneral.setTextColor(resources.getColor(R.color.balance_yellow, theme)) // Amarillo: te deben
                    } else if (saldoGeneralFinal < 0) {
                        tvSaldoGeneral.setTextColor(resources.getColor(R.color.error_color, theme)) // Rojo: debes
                    } else {
                        tvSaldoGeneral.setTextColor(resources.getColor(R.color.success_color, theme)) // Verde: saldo cero
                    }
                    
                    // Saldos de jefe (bordado/planchado)
                    val tvJefeSaldos = findViewById<TextView>(R.id.tv_jefe_saldos)
                    tvJefeSaldos.text = "BP: S/ ${String.format("%.2f", saldoBordadoPlanchado)}"
                    
                    val tvJefeSaldo = findViewById<TextView>(R.id.tv_jefe_saldo)
                    val jefeSaldoFinal = saldoBordadoPlanchado - config.adelantos
                    tvJefeSaldo.text = "Saldo: S/ ${String.format("%.2f", jefeSaldoFinal)}"
                    if (jefeSaldoFinal > 0) {
                        tvJefeSaldo.setTextColor(resources.getColor(R.color.balance_yellow, theme)) // Amarillo: te deben
                    } else if (jefeSaldoFinal < 0) {
                        tvJefeSaldo.setTextColor(resources.getColor(R.color.error_color, theme)) // Rojo: debes
                    } else {
                        tvJefeSaldo.setTextColor(resources.getColor(R.color.success_color, theme)) // Verde: saldo cero
                    }
                    
                    // Chompas (Clemente)
                    val tvChompasNumero = findViewById<TextView>(R.id.tv_chompas_numero)
                    tvChompasNumero.text = registrosChompas.size.toString()
                    
                    val tvClementeSaldo = findViewById<TextView>(R.id.tv_clemente_saldo)
                    tvClementeSaldo.text = "Saldo: S/ ${String.format("%.2f", saldoChompas)}"
                    if (saldoChompas > 0) {
                        tvClementeSaldo.setTextColor(resources.getColor(R.color.balance_yellow, theme)) // Amarillo: te deben
                    } else if (saldoChompas < 0) {
                        tvClementeSaldo.setTextColor(resources.getColor(R.color.error_color, theme)) // Rojo: debes
                    } else {
                        tvClementeSaldo.setTextColor(resources.getColor(R.color.success_color, theme)) // Verde: saldo cero
                    }
                    
                    // Ponchos (Lalo)
                    val tvPonchosNumero = findViewById<TextView>(R.id.tv_ponchos_numero)
                    tvPonchosNumero.text = cantidadPonchos.toString()
                    
                    val tvLaloSaldo = findViewById<TextView>(R.id.tv_lalo_saldo)
                    tvLaloSaldo.text = "Saldo: S/ ${String.format("%.2f", saldoPonchos)}"
                    if (saldoPonchos > 0) {
                        tvLaloSaldo.setTextColor(resources.getColor(R.color.balance_yellow, theme)) // Amarillo: te deben
                    } else if (saldoPonchos < 0) {
                        tvLaloSaldo.setTextColor(resources.getColor(R.color.error_color, theme)) // Rojo: debes
                    } else {
                        tvLaloSaldo.setTextColor(resources.getColor(R.color.success_color, theme)) // Verde: saldo cero
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "Error al actualizar saldos: ${e.message}", Toast.LENGTH_SHORT).show()
                    Log.e("MainActivity", "Error actualizando saldos", e)
                }
            }
        }
    }
    
    // Generar un informe PDF
    private fun generarPDF() {
        // Crear instancia de repositorio
        val repository = com.moises.sam.data.SamRepository(this)
        
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                // Obtener la configuración actual para acceder a los saldos
                val config = repository.getConfiguracion()
                
                // Obtener todos los registros no pagados
                val registrosBP = repository.getRegistrosBordadoPlanchado()
                val registrosChompas = repository.getRegistrosChompas() 
                val registrosPonchos = repository.getRegistrosPonchos()
                val registros = registrosBP + registrosChompas + registrosPonchos
                
                // Obtener pagos realizados
                val pagos = repository.getAllPagos()
                
                // Calcular totales
                val totalServicios = registros.sumOf { it.total }
                val adelantos = config.adelantos
                val saldoAnterior = config.saldoAnterior ?: 0.0
                val totalPagos = pagos.sumOf { it.monto }
                
                // Calcular saldo final que se arrastrará al siguiente ciclo
                val saldoFinal = totalServicios + saldoAnterior - adelantos - totalPagos
                
                // Generar PDF usando PdfGenerator
                val pdfGenerator = com.moises.sam.pdf.PdfGenerator(this@MainActivity)
                val pdfFile = pdfGenerator.generarInformePDF(registros, pagos, saldoAnterior, adelantos, totalPagos, saldoFinal)
                
                if (pdfFile != null) {
                    // Marcar todos los registros como pagados
                    registros.forEach { registro ->
                        repository.marcarRegistroComoPagado(registro.id)
                    }
                    
                    // Resetear adelantos y guardar saldo final como saldo anterior para el próximo ciclo
                    repository.actualizarDespuesDeGenerarPDF(saldoFinal)
                    
                    // Borrar pagos registrados ya que están incluidos en el PDF
                    repository.eliminarTodosPagos()
                    
                    // Actualizar la UI en el hilo principal
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@MainActivity, "PDF generado: ${pdfFile.name}", Toast.LENGTH_LONG).show()
                        actualizarSaldos() // Actualizar la UI para reflejar los cambios
                    }
                } else {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@MainActivity, "Error al generar PDF", Toast.LENGTH_SHORT).show()
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "Error al generar PDF: ${e.message}", Toast.LENGTH_SHORT).show()
                    Log.e("MainActivity", "Error generando PDF", e)
                }
            }
        }
    }
    
    override fun onResume() {
        super.onResume()
        // Actualizar datos cada vez que se muestre la actividad
        actualizarSaldos()
    }
    
    /**
     * Muestra un diálogo para seleccionar el tipo de servicio a registrar
     */
    private fun mostrarDialogoSeleccionServicio() {
        val dialog = android.app.Dialog(this)
        dialog.requestWindowFeature(android.view.Window.FEATURE_NO_TITLE)
        dialog.setContentView(R.layout.dialog_select_service)
        dialog.window?.setBackgroundDrawable(android.graphics.drawable.ColorDrawable(android.graphics.Color.TRANSPARENT))
        dialog.setCancelable(true)
        
        // Configurar botones
        val btnBordado = dialog.findViewById<Button>(R.id.btn_bordado)
        val btnPlanchado = dialog.findViewById<Button>(R.id.btn_planchado)
        val btnChompa = dialog.findViewById<Button>(R.id.btn_chompa)
        val btnPoncho = dialog.findViewById<Button>(R.id.btn_poncho)
        val btnCancel = dialog.findViewById<Button>(R.id.btn_cancel)
        
        // Configurar listeners
        btnBordado.setOnClickListener {
            dialog.dismiss()
            mostrarDialogoRegistroServicio(TipoServicio.BORDADO) { cantidad ->
                val total = cantidad * 0.50
                registrarServicio(TipoServicio.BORDADO, cantidad, total)
                Toast.makeText(this, "Bordado registrado: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
                actualizarSaldos()
            }
        }
        
        btnPlanchado.setOnClickListener {
            dialog.dismiss()
            mostrarDialogoRegistroServicio(TipoServicio.PLANCHADO) { cantidad ->
                val total = cantidad * 1.00
                registrarServicio(TipoServicio.PLANCHADO, cantidad, total)
                Toast.makeText(this, "Planchado registrado: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
                actualizarSaldos()
            }
        }
        
        btnChompa.setOnClickListener {
            dialog.dismiss()
            mostrarDialogoRegistroServicio(TipoServicio.CHOMPA) { cantidad ->
                val precioUnitario = 1.00
                val total = cantidad * precioUnitario
                registrarServicio(TipoServicio.CHOMPA, cantidad, total)
                Toast.makeText(this, "Chompa registrada: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
                actualizarSaldos()
            }
        }
        
        btnPoncho.setOnClickListener {
            dialog.dismiss()
            mostrarDialogoRegistroServicio(TipoServicio.PONCHO) { cantidad ->
                val total = cantidad * 2.50
                registrarServicio(TipoServicio.PONCHO, cantidad, total)
                Toast.makeText(this, "Poncho registrado: $cantidad unidades - S/ $total", Toast.LENGTH_SHORT).show()
                actualizarSaldos()
            }
        }
        
        btnCancel.setOnClickListener {
            dialog.dismiss()
        }
        
        dialog.show()
    }
    
    /**
     * Muestra un diálogo con la tabla de registros según el tipo especificado
     */
    private fun mostrarDialogoVerRegistros(titulo: String, tiposServicio: List<TipoServicio>) {
        lifecycleScope.launch {
            // Crear el diálogo
            val dialog = android.app.Dialog(this@MainActivity)
            dialog.requestWindowFeature(android.view.Window.FEATURE_NO_TITLE)
            dialog.setContentView(R.layout.dialog_ver_registros)
            dialog.window?.setBackgroundDrawable(android.graphics.drawable.ColorDrawable(android.graphics.Color.TRANSPARENT))
            dialog.setCancelable(true)
            
            // Configurar título
            val tvTitle = dialog.findViewById<TextView>(R.id.tv_dialog_title)
            tvTitle.text = titulo
            
            // Obtener registros según el tipo
            val registros = withContext(Dispatchers.IO) {
                when {
                    tiposServicio.contains(TipoServicio.BORDADO) || tiposServicio.contains(TipoServicio.PLANCHADO) ->
                        repository.getRegistrosBordadoPlanchado().map { it.toRegistro() }
                    tiposServicio.contains(TipoServicio.CHOMPA) ->
                        repository.getRegistrosChompas().map { it.toRegistro() }
                    tiposServicio.contains(TipoServicio.PONCHO) ->
                        repository.getRegistrosPonchos().map { it.toRegistro() }
                    else -> emptyList()
                }
            }
            
            val tableLayout = dialog.findViewById<TableLayout>(R.id.table_registros)
            val noRecordsText = dialog.findViewById<TextView>(R.id.tv_no_records)
            
            // Verificar si hay registros
            if (registros.isEmpty()) {
                tableLayout.visibility = android.view.View.GONE
                noRecordsText.visibility = android.view.View.VISIBLE
            } else {
                tableLayout.visibility = android.view.View.VISIBLE
                noRecordsText.visibility = android.view.View.GONE
                
                // Formato de fecha
                val dateFormat = SimpleDateFormat("dd/MM/yy", Locale.getDefault())
                
                // Agregar filas a la tabla
                registros.forEach { registro ->
                    val row = TableRow(this@MainActivity)
                    row.layoutParams = TableLayout.LayoutParams(
                        TableLayout.LayoutParams.MATCH_PARENT,
                        TableLayout.LayoutParams.WRAP_CONTENT
                    )
                    row.setPadding(5, 5, 5, 5)
                    
                    // Columna: Fecha
                    val fechaCell = TextView(this@MainActivity)
                    fechaCell.text = dateFormat.format(registro.fecha)
                    fechaCell.setTextColor(resources.getColor(R.color.white, theme))
                    row.addView(fechaCell)
                    
                    // Columna: Tipo
                    val tipoCell = TextView(this@MainActivity)
                    tipoCell.text = when (registro.tipo) {
                        TipoServicio.BORDADO -> "Bordado"
                        TipoServicio.PLANCHADO -> "Planchado"
                        TipoServicio.CHOMPA -> "Chompa"
                        TipoServicio.PONCHO -> "Poncho"
                        else -> "Otro"
                    }
                    tipoCell.setTextColor(resources.getColor(R.color.white, theme))
                    row.addView(tipoCell)
                    
                    // Columna: Cantidad
                    val cantidadCell = TextView(this@MainActivity)
                    cantidadCell.text = registro.cantidad.toString()
                    cantidadCell.setTextColor(resources.getColor(R.color.white, theme))
                    row.addView(cantidadCell)
                    
                    // Columna: Monto
                    val montoCell = TextView(this@MainActivity)
                    montoCell.text = String.format("S/ %.2f", registro.total)
                    montoCell.setTextColor(resources.getColor(R.color.white, theme))
                    row.addView(montoCell)
                    
                    // Alternar colores de fila para mejor legibilidad
                    if (registros.indexOf(registro) % 2 == 0) {
                        row.setBackgroundColor(resources.getColor(R.color.table_row_even, theme))
                    } else {
                        row.setBackgroundColor(resources.getColor(R.color.table_row_odd, theme))
                    }
                    
                    tableLayout.addView(row)
                }
            }
            
            // Configurar botón cerrar
            val btnClose = dialog.findViewById<Button>(R.id.btn_close)
            btnClose.setOnClickListener {
                dialog.dismiss()
            }
            
            // Mostrar diálogo
            dialog.show()
        }
    }
}